# Session 6: 이미지 보안과 취약점 관리

## 📍 교과과정에서의 위치
이 세션은 **Week 3 > Day 2 > Session 6**로, 컨테이너 이미지 보안과 취약점 관리 전략을 학습합니다.

## 학습 목표 (5분)
- **컨테이너 이미지** 보안 스캔과 **취약점 탐지** 방법 이해
- **이미지 서명**과 **검증** 메커니즘 학습
- **취약점 데이터베이스** 활용과 **위험도 평가** 방법 파악
- **보안 정책** 기반 이미지 관리와 **자동화** 전략 이해

## 1. 컨테이너 이미지 보안 스캔 (15분)

### 이미지 보안 파이프라인

```mermaid
graph TB
    subgraph "이미지 보안 파이프라인"
        A[소스 코드] --> B[빌드]
        B --> C[이미지 스캔]
        C --> D[취약점 분석]
        D --> E[정책 검증]
        E --> F[레지스트리 푸시]
        F --> G[배포 전 스캔]
        G --> H[런타임 모니터링]
    end
```

### 이미지 스캔 전략
```
컨테이너 이미지 보안 스캔:

스캔 도구 및 기술:
   🔹 정적 분석 도구:
      • Trivy: 종합 취약점 스캐너
      • Clair: CoreOS 오픈소스 스캐너
      • Anchore: 정책 기반 분석
      • Snyk: 개발자 친화적 도구
      • Twistlock/Prisma: 엔터프라이즈 솔루션
   🔹 클라우드 네이티브 도구:
      • Amazon ECR 스캔
      • Google Container Analysis
      • Azure Container Registry 스캔
      • Harbor 내장 스캔
      • Quay 보안 스캔
   🔹 통합 플랫폼:
   🔹 GitLab Container Scanning
   🔹 GitHub Security
   🔹 Jenkins 플러그인
   🔹 CI/CD 파이프라인 통합
   🔹 Kubernetes Admission Controller

스캔 범위 및 대상:
   🔹 운영체제 취약점:
      • 베이스 이미지 취약점
      • 패키지 관리자 취약점
      • 시스템 라이브러리
      • 커널 취약점
      • 설정 오류
   🔹 애플리케이션 취약점:
      • 언어별 패키지 취약점
      • 의존성 라이브러리
      • 프레임워크 취약점
      • 커스텀 코드 분석
      • 설정 파일 검사
   🔹 시크릿 및 민감 정보:
      • 하드코딩된 패스워드
      • API 키 및 토큰
      • 인증서 및 키
      • 데이터베이스 연결 정보
      • 환경 변수 노출
   🔹 설정 및 정책:
   🔹 Dockerfile 모범 사례
   🔹 사용자 권한 설정
   🔹 포트 노출 검사
   🔹 볼륨 마운트 검사
   🔹 보안 컨텍스트 검증

스캔 시점 및 전략:
   🔹 빌드 시점 스캔:
      • CI/CD 파이프라인 통합
      • 빌드 실패 조건 설정
      • 취약점 임계값 설정
      • 자동 수정 제안
      • 보고서 생성
   🔹 레지스트리 스캔:
      • 푸시 시 자동 스캔
      • 정기적 재스캔
      • 새로운 취약점 탐지
      • 이미지 태그별 관리
      • 스캔 결과 메타데이터
   🔹 배포 전 스캔:
      • Admission Controller 통합
      • 정책 기반 배포 제어
      • 실시간 취약점 확인
      • 예외 처리 메커니즘
      • 감사 로깅
   🔹 런타임 스캔:
   🔹 실행 중 이미지 모니터링
   🔹 새로운 취약점 알림
   🔹 패치 가용성 확인
   🔹 자동 업데이트 트리거
   🔹 인시던트 대응 연동
```

## 2. 이미지 서명과 검증 메커니즘 (12분)

### 이미지 서명 아키텍처

```mermaid
graph TB
    subgraph "이미지 서명 및 검증"
        A[개발자] --> B[이미지 빌드]
        B --> C[서명 생성]
        C --> D[레지스트리 푸시]
        
        E[배포 시스템] --> F[서명 검증]
        F --> G[정책 확인]
        G --> H[배포 승인/거부]
        
        I[키 관리] --> C
        I --> F
    end
```

### 서명 및 검증 전략
```
이미지 서명 및 검증:

서명 기술 및 표준:
   🔹 Docker Content Trust:
      • Notary 기반 서명
      • TUF (The Update Framework)
      • 계층적 키 관리
      • 역할 기반 서명
      • 오프라인 키 지원
   🔹 Cosign (Sigstore):
      • 간단한 서명 도구
      • OCI 표준 호환
      • 키리스 서명 지원
      • 투명성 로그 통합
      • OIDC 기반 인증
   🔹 클라우드 서명 서비스:
      • AWS Signer
      • Azure Code Signing
      • Google Binary Authorization
      • 관리형 키 서비스
      • 하드웨어 보안 모듈
   🔹 엔터프라이즈 솔루션:
   🔹 Red Hat 서명
   🔹 VMware 서명
   🔹 IBM 서명 서비스
   🔹 커스텀 PKI 통합
   🔹 하이브리드 솔루션

키 관리 전략:
   🔹 키 생성 및 저장:
      • 오프라인 루트 키
      • 온라인 서명 키
      • 하드웨어 보안 모듈
      • 클라우드 키 관리
      • 키 백업 및 복구
   🔹 키 로테이션:
      • 정기적 키 갱신
      • 침해 시 긴급 로테이션
      • 점진적 키 전환
      • 이전 서명 유효성
      • 자동화된 프로세스
   🔹 접근 제어:
      • 역할 기반 키 접근
      • 다중 서명 요구
      • 승인 워크플로우
      • 감사 로깅
      • 키 사용 모니터링
   🔹 키 폐기:
   🔹 키 만료 관리
   🔹 폐기 키 목록 관리
   🔹 서명 무효화
   🔹 알림 및 경고
   🔹 법적 요구사항 준수

검증 정책 및 시행:
   🔹 정책 정의:
      • 신뢰할 수 있는 서명자
      • 필수 서명 요구사항
      • 서명 유효성 검사
      • 예외 처리 규칙
      • 감사 요구사항
   🔹 시행 지점:
      • 레지스트리 레벨
      • Admission Controller
      • 런타임 검증
      • CI/CD 파이프라인
      • 개발자 도구
   🔹 검증 프로세스:
      • 서명 존재 확인
      • 서명자 신원 검증
      • 서명 무결성 확인
      • 정책 준수 검사
      • 결과 로깅
   🔹 예외 처리:
   🔹 긴급 배포 절차
   🔹 레거시 이미지 처리
   🔹 개발 환경 예외
   🔹 승인 워크플로우
   🔹 임시 정책 완화
```

## 3. 취약점 데이터베이스 활용 (10분)

### 취약점 관리 생태계

```mermaid
graph TB
    subgraph "취약점 데이터 소스"
        A[CVE Database] --> B[NVD]
        C[Vendor Advisories] --> D[보안 공지]
        E[Security Research] --> F[연구 기관]
        G[Threat Intelligence] --> H[위협 정보]
    end
    
    subgraph "취약점 분석"
        I[CVSS 점수] --> J[위험도 평가]
        K[Exploitability] --> L[악용 가능성]
        M[Business Impact] --> N[비즈니스 영향]
    end
```

### 취약점 관리 전략
```
취약점 데이터베이스 활용:

주요 취약점 데이터베이스:
   🔹 CVE (Common Vulnerabilities and Exposures):
      • 표준 취약점 식별자
      • 글로벌 표준
      • 벤더 중립적
      • 공개 데이터베이스
      • 지속적 업데이트
   🔹 NVD (National Vulnerability Database):
      • NIST 운영
      • CVSS 점수 제공
      • 상세한 취약점 정보
      • 패치 정보 포함
      • API 접근 지원
   🔹 벤더별 보안 공지:
      • Red Hat Security Advisories
      • Ubuntu Security Notices
      • Debian Security Advisories
      • Alpine Security
      • 언어별 보안 공지
   🔹 상용 위협 인텔리전스:
   🔹 실시간 위협 정보
   🔹 제로데이 취약점
   🔹 악용 코드 정보
   🔹 공격 트렌드 분석
   🔹 맞춤형 위험 평가

위험도 평가 및 우선순위:
   🔹 CVSS (Common Vulnerability Scoring System):
      • 기본 점수 (Base Score)
      • 시간적 점수 (Temporal Score)
      • 환경적 점수 (Environmental Score)
      • 0-10 점수 체계
      • 심각도 분류
   🔹 비즈니스 영향 분석:
      • 자산 중요도
      • 데이터 민감도
      • 서비스 가용성
      • 컴플라이언스 영향
      • 재정적 손실
   🔹 악용 가능성 평가:
      • 공개된 익스플로잇
      • 공격 복잡도
      • 필요한 권한
      • 사용자 상호작용
      • 네트워크 접근성
   🔹 우선순위 매트릭스:
   🔹 높음: 즉시 패치
   🔹 중간: 계획된 패치
   🔹 낮음: 모니터링
   🔹 정보: 인지만 필요
   🔹 무시: 영향 없음

자동화된 취약점 관리:
   🔹 취약점 스캔 자동화:
      • 정기적 스캔 스케줄
      • 새로운 취약점 탐지
      • 델타 스캔 최적화
      • 대용량 이미지 처리
      • 클라우드 스케일링
   🔹 알림 및 보고:
      • 실시간 알림
      • 위험도별 에스컬레이션
      • 대시보드 시각화
      • 정기 보고서
      • 컴플라이언스 보고
   🔹 자동 수정:
      • 패치 가용성 확인
      • 자동 이미지 업데이트
      • 테스트 자동화
      • 점진적 배포
      • 롤백 메커니즘
   🔹 정책 기반 대응:
   🔹 위험도별 대응 정책
   🔹 SLA 기반 패치 일정
   🔹 비즈니스 규칙 적용
   🔹 예외 처리 워크플로우
   🔹 승인 프로세스 통합
```

## 4. 보안 정책 기반 이미지 관리 (10분)

### 정책 기반 관리 아키텍처

```mermaid
graph TB
    subgraph "정책 기반 이미지 관리"
        A[보안 정책] --> B[이미지 스캔]
        B --> C[정책 평가]
        C --> D[승인/거부]
        
        E[Admission Controller] --> F[배포 시 검증]
        G[Registry Webhook] --> H[푸시 시 검증]
        I[Runtime Monitor] --> J[실행 중 모니터링]
    end
```

### 정책 관리 전략
```
보안 정책 기반 이미지 관리:

정책 정의 및 관리:
   🔹 보안 정책 유형:
      • 취약점 임계값 정책
      • 이미지 소스 정책
      • 서명 요구사항 정책
      • 라이선스 정책
      • 컴플라이언스 정책
   🔹 정책 적용 범위:
      • 글로벌 정책
      • 네임스페이스별 정책
      • 애플리케이션별 정책
      • 환경별 정책
      • 팀별 정책
   🔹 정책 우선순위:
      • 계층적 정책 구조
      • 상속 및 오버라이드
      • 예외 처리 규칙
      • 충돌 해결 메커니즘
      • 정책 검증
   🔹 정책 생명주기:
   🔹 정책 개발 및 테스트
   🔹 승인 및 배포
   🔹 모니터링 및 평가
   🔹 업데이트 및 개선
   🔹 폐기 및 아카이브

자동화된 정책 시행:
   🔹 Admission Controller:
      • ValidatingAdmissionWebhook
      • MutatingAdmissionWebhook
      • OPA Gatekeeper
      • Falco 통합
      • 커스텀 컨트롤러
   🔹 레지스트리 통합:
      • Harbor 정책 엔진
      • Quay 보안 스캔
      • ECR 스캔 결과
      • 웹훅 기반 검증
      • API 기반 통합
   🔹 CI/CD 통합:
      • 빌드 게이트
      • 품질 게이트
      • 보안 게이트
      • 승인 워크플로우
      • 자동 수정
   🔹 런타임 모니터링:
   🔹 실행 중 정책 검증
   🔹 새로운 취약점 탐지
   🔹 정책 위반 알림
   🔹 자동 격리
   🔹 인시던트 대응

예외 처리 및 거버넌스:
   🔹 예외 승인 프로세스:
      • 위험 평가
      • 비즈니스 정당성
      • 승인 권한자
      • 시간 제한
      • 모니터링 강화
   🔹 임시 정책 완화:
      • 긴급 상황 대응
      • 제한된 시간
      • 추가 보안 조치
      • 승인 추적
      • 자동 복원
   🔹 정책 위반 대응:
      • 자동 차단
      • 알림 발송
      • 에스컬레이션
      • 근본 원인 분석
      • 개선 조치
   🔹 컴플라이언스 관리:
   🔹 규제 요구사항 매핑
   🔹 감사 증적 관리
   🔹 정기적 검토
   🔹 보고서 생성
   🔹 외부 감사 지원
```

## 💬 그룹 토론: 이미지 보안 전략의 균형점 (8분)

### 토론 주제
**"개발 속도와 보안성을 균형있게 고려한 컨테이너 이미지 보안 전략은?"**

### 토론 가이드라인

#### 보안 vs 개발 속도 (3분)
- **스캔 시점**: 빌드 시 vs 배포 시 vs 런타임 스캔의 장단점
- **임계값 설정**: 취약점 차단 기준과 개발 생산성 영향
- **자동화 수준**: 완전 자동화 vs 수동 검토의 적절한 조합

#### 비용 vs 효과 (3분)
- **도구 선택**: 오픈소스 vs 상용 도구의 비용 대비 효과
- **인력 투입**: 보안 전문가 vs 개발자 교육의 효율성
- **인프라 비용**: 스캔 인프라와 스토리지 비용 고려

#### 실무 적용 (2분)
- **점진적 도입**: 기존 시스템에 보안 스캔 도입 전략
- **문화 변화**: 개발팀의 보안 의식 제고 방안
- **측정 지표**: 이미지 보안 개선 효과 측정 방법

## 💡 핵심 개념 정리
- **이미지 스캔**: 정적 분석을 통한 취약점 및 보안 이슈 탐지
- **이미지 서명**: 무결성과 출처 검증을 위한 디지털 서명
- **취약점 관리**: CVE 데이터베이스 활용과 위험도 기반 우선순위
- **정책 기반 관리**: 자동화된 보안 정책 시행과 예외 처리

## 📚 참고 자료
- [Container Image Security](https://kubernetes.io/docs/concepts/security/container-image-security/)
- [Trivy Documentation](https://aquasecurity.github.io/trivy/)
- [Cosign Documentation](https://docs.sigstore.dev/cosign/overview/)
- [OPA Gatekeeper](https://open-policy-agent.github.io/gatekeeper/)

## 다음 세션 준비
다음 세션에서는 **감사 로깅과 컴플라이언스**에 대해 학습합니다. Kubernetes 감사 로깅 구성과 규제 요구사항 대응 전략을 다룰 예정입니다.