# Session 1: Docker 네트워킹 모델 이론

## 📍 교과과정에서의 위치
이 세션은 **Week 1 > Day 5 > Session 1**로, Docker의 네트워킹 아키텍처를 이론적으로 학습합니다. 지난 4일간 학습한 컨테이너 기술을 바탕으로 네트워킹 모델과 통신 메커니즘을 이해합니다.

## 학습 목표 (5분)
- Docker **네트워킹 아키텍처**와 **모델 분류** 이해
- **네트워크 드라이버** 종류와 **특성** 학습
- **컨테이너 간 통신** 메커니즘과 **격리** 원리 파악

## 1. Docker 네트워킹 아키텍처 (15분)

### 네트워킹 계층 구조

```mermaid
graph TB
    subgraph "Docker 네트워킹 스택"
        A[애플리케이션 레이어] --> B[컨테이너 네트워크]
        B --> C[Docker 네트워크 드라이버]
        C --> D[Linux 네트워킹]
        D --> E[물리 네트워크]
    end
    
    subgraph "네트워크 드라이버"
        F[bridge] --> G[host]
        G --> H[overlay]
        H --> I[macvlan]
        I --> J[none]
    end
```

### 네트워킹 모델 분류

#### 1. 브리지 네트워크 (기본값)
```
브리지 네트워크 구조:
Host Network (172.17.0.1)
├── docker0 브리지
│   ├── Container A (172.17.0.2)
│   ├── Container B (172.17.0.3)
│   └── Container C (172.17.0.4)
└── 외부 네트워크 연결

특징:
- 기본 네트워크 모드
- NAT를 통한 외부 통신
- 컨테이너 간 격리 제공
- 포트 매핑 필요
```

#### 2. 호스트 네트워크
```
호스트 네트워크 구조:
Host Network Interface
├── 호스트 프로세스들
└── 컨테이너 (호스트 네트워크 공유)

특징:
- 호스트와 동일한 네트워크 스택
- 최고 성능 (네트워크 오버헤드 없음)
- 포트 충돌 가능성
- 보안 격리 감소
```

#### 3. 오버레이 네트워크
```
오버레이 네트워크 구조:
Node A                    Node B
├── Container 1 ←--------→ Container 3
└── Container 2 ←--------→ Container 4
     │                      │
     └── VXLAN 터널 --------┘

특징:
- 다중 호스트 통신
- VXLAN 캡슐화
- Swarm 모드에서 사용
- 서비스 디스커버리 내장
```

## 2. 네트워크 격리와 보안 (15분)

### 네트워크 네임스페이스

```mermaid
graph LR
    subgraph "Host Network Namespace"
        A[eth0] --> B[docker0]
    end
    
    subgraph "Container 1 Namespace"
        C[eth0] --> D[veth pair]
    end
    
    subgraph "Container 2 Namespace"
        E[eth0] --> F[veth pair]
    end
    
    B --> D
    B --> F
```

### 격리 메커니즘
```
네트워크 격리 계층:
├── 네임스페이스 격리
│   ├── 독립적인 네트워크 스택
│   ├── 별도의 라우팅 테이블
│   └── 격리된 인터페이스
├── 방화벽 규칙
│   ├── iptables 자동 설정
│   ├── 컨테이너별 규칙
│   └── 포트 매핑 제어
└── 트래픽 제어
    ├── 대역폭 제한
    ├── QoS 정책
    └── 네트워크 정책
```

## 3. 서비스 디스커버리 이론 (10분)

### DNS 기반 서비스 디스커버리

```mermaid
graph TB
    A[컨테이너 A] --> B[내장 DNS 서버]
    C[컨테이너 B] --> B
    D[컨테이너 C] --> B
    
    B --> E[서비스 레지스트리]
    E --> F[컨테이너 이름 해석]
    E --> G[서비스 이름 해석]
    E --> H[네트워크 별칭 해석]
```

### 서비스 디스커버리 패턴
```
디스커버리 방식:
├── 컨테이너 이름 기반
│   └── container_name → IP 주소
├── 서비스 이름 기반
│   └── service_name → 로드 밸런싱
├── 네트워크 별칭
│   └── alias → 그룹 해석
└── 외부 DNS 통합
    └── 기존 DNS와 연동
```

## 4. 네트워크 성능 고려사항 (10분)

### 성능 비교 매트릭스

| 네트워크 모드 | 성능 | 격리성 | 복잡도 | 사용 사례 |
|---------------|------|--------|--------|-----------|
| **host** | 최고 | 낮음 | 낮음 | 고성능 애플리케이션 |
| **bridge** | 중간 | 높음 | 중간 | 일반적인 용도 |
| **overlay** | 낮음 | 높음 | 높음 | 다중 호스트 |
| **macvlan** | 높음 | 높음 | 높음 | 레거시 통합 |

### 성능 최적화 전략
```
최적화 방법론:
├── 네트워크 모드 선택
│   ├── 성능 요구사항 분석
│   ├── 보안 요구사항 고려
│   └── 운영 복잡도 평가
├── 드라이버 최적화
│   ├── 적절한 MTU 설정
│   ├── 버퍼 크기 조정
│   └── 하드웨어 가속 활용
└── 모니터링 및 튜닝
    ├── 네트워크 지연 측정
    ├── 처리량 분석
    └── 병목 지점 식별
```

## 5. 그룹 토론: 컨테이너 네트워킹의 특징 (10분)

### 토론 주제
**"컨테이너 네트워킹이 기존 가상머신 네트워킹과 다른 핵심적인 차이점은 무엇인가?"**

### 토론 가이드라인

#### 비교 관점 (3분)
- **아키텍처 차이**: 하이퍼바이저 vs 컨테이너 런타임
- **성능 특성**: 오버헤드와 처리량
- **관리 복잡도**: 설정과 운영

#### 장단점 분석 (4분)
- **컨테이너 네트워킹 장점**: 경량성, 유연성, 자동화
- **컨테이너 네트워킹 단점**: 복잡성, 디버깅 어려움
- **적용 시나리오**: 언제 어떤 방식을 선택할 것인가

#### 미래 전망 (3분)
- **기술 발전 방향**: eBPF, 서비스 메시
- **표준화 동향**: CNI, OCI 네트워킹
- **클라우드 네이티브**: Kubernetes와의 통합

## 💡 핵심 키워드
- **네트워크 드라이버**: bridge, host, overlay, macvlan
- **격리 메커니즘**: 네임스페이스, iptables, 트래픽 제어
- **서비스 디스커버리**: DNS 기반, 자동 해석, 로드 밸런싱
- **성능 최적화**: 모드 선택, 드라이버 튜닝, 모니터링

## 📚 참고 자료
- [Docker Networking Overview](https://docs.docker.com/network/)
- [Container Network Interface (CNI)](https://github.com/containernetworking/cni)
- [Linux Network Namespaces](https://man7.org/linux/man-pages/man7/network_namespaces.7.html)

## 다음 세션 준비
다음 세션에서는 **CNI와 네트워크 드라이버 구조**에 대해 학습합니다. 네트워크 플러그인 아키텍처와 표준화에 대해 이해할 예정입니다.
